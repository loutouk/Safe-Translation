let pile = ref [] ;
let id = ref 0 ;
let generateId -> let x = !id in id := !id + 1 ; x ;
let pushId id -> pile := id::!pile ;
let popId -> pile := pop !pile ;
let checkId id -> if peek !pile = id then raise{} else () ;

let isPrime n externalFunc ->
    let auxA a ->
      let auxB b ->
        if b = n then FALSE
        else if (a * b) = n then
          TRUE
        else
          let id = generateId{} in pushId{id} ; auxB {b+1}
      in
      if a = n then TRUE else
      if auxB {a} then
        FALSE
      else
        externalFunc {n} ; checkId{id} ; auxA {a+1}
    in
    auxA {2} ; let id = generateId{} in pushId{id} ; externalFunc {} ; checkId{id}
  in
  let nextPrime n ->
    let id = generateId{} in pushId{id} ; if isPrime {n} then n else nextPrime {n+1}
  in
  nextPrime {3000} ; externalFunc {} ; checkId{id} ; popId{}  ; popId{}  ; popId{}

Process finished with exit code 0
